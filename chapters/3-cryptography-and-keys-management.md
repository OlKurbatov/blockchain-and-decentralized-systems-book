# 3 Cryptography and keys management
## 3.1 Introduction to cryptography
In this subsection, without going into a deep dive, we are going to get acquainted with cryptography as a science, its 
tasks, and basic mechanisms. We will consider the specific cryptographic mechanisms and functions applied in the Bitcoin 
protocol. Also, we will pay attention to the working features of a digital signature and the digital keys used for 
operating with it; these aspects are primarily of a practical nature.

*Cryptography is the science of information protection using mathematical methods*. Its role in the development of 
information systems is hard to overestimate. Bitcoin became the world's first payment system where the main processes 
and operations are cryptographically protected.

You will have an opportunity to learn the basic principles of information security and consider the most important 
cryptographic algorithms related to the Bitcoin protocol.

### Principles of cryptographic information security
The development of cryptography began in ancient times. Its history dates back more than four thousand years. Initially, 
cryptography solved only one problem—ensuring confidentiality when transferring and storing data. To solve this problem 
then, such mechanisms as text shuffling, mixing of text symbols, use of alternative alphabets, etc. were used.

At present, cryptography uses a mathematical basis. It involves special transformations which are defined in branches of 
mathematics such as number and information theories, group theory, ring theory, field theory, as well as in some others. 
This kind of mathematics is not well-known to most people since it is not taught in most educational institutions.

Modern cryptography includes symmetric and asymmetric encryption schemes, digital signature schemes, data hashing 
schemes, key management methods, zero-knowledge proof schemes, post-quantum cryptography, etc.

> **Basic security services**
>> * Ensuring data ***confidentiality***
>> * Ensuring data ***integrity***
>> * Ensuring data ***accessibility***
>> * Ensuring data ***authenticity***

*Confidentiality* implies that unauthorized persons cannot access the semantic content of a document that is stored or 
transmitted. Most often this service is provided via encryption (symmetric or asymmetric).

*Integrity* implies that unauthorized persons cannot modify data unnoticeably. The task of verifying the integrity of 
data read from a carrier or received from a network is typically solved via hashing and checksum verification.

*Accessibility* implies that the parties having the right to access some information will definitely gain access to it.

*Authenticity* implies the ability to prove that data have definitely been received from a specific author. The task of 
ensuring the authenticity of data is typically solved using a digital signature. We give its simplified definition 
below.

> **_NOTE:_** *Unlike the other above-listed services, accessibility is ensured with other than cryptographic methods 
> (redundancy, usage of uninterruptible power supply systems, and so on).*

### Concept of key
A modern cryptographic key is a *digital sequence of a particular length created according to certain rules using random 
number generators and computed by a special algorithm*. A cryptographic key is the core part of cryptographic operations. 
Security of most cryptographic schemes is generally dependent on the security of keys.

In a general sense, a *private key* in Bitcoin is a large random natural number. There are special software and hardware 
random number generators which form a random sequence of a constant length (in the case of software number generators, 
it is actually more proper to speak about *pseudorandom numbers*). A private key is a natural number generated by this 
random sequence of a constant length. A public key is calculated from a private key by means of mathematical 
transformations (Fig. 3.1).

[Figure 3.1] -  Public and private keys relation

> **_NOTE:_** *When dealing with cryptographic algorithms that are considered sufficiently reliable (according to 
> cryptographic standards), the inverse transformation—obtaining a private key from a public key—cannot be done in 
> practice.*

In the field of cryptanalysis, there are certain methods which allow attacking cryptographic schemes more efficiently 
than by simply iterating over numbers. However, for keys of a long length, a practical implementation of the attack 
requires enormous computational power. This process would take a very long time (billions of years or even longer using 
current algorithms and hardware).

### Generation and processing of secret keys
In practice, it is very important that the schemes of key and digital signature generation work correctly and the 
security mechanisms be reliable. In cryptocurrencies, the *ownership of coins is proved by the knowledge of the private 
key which is required to calculate a valid digital signature*. For the key owner, it is important that no one else is 
able to steal, calculate, or generate the same key data.

What does it mean? Users of Bitcoin and other cryptocurrencies should use reliable random number generators (and truly 
random seeds for them) that produce objectively random sequences that could not be repeated under any other conditions. 
As we have already noted, generators can either be software or hardware. What is the difference?

*Software generators* cannot generate numbers which are random enough. They generate so-called pseudorandom numbers. 
This means that after a certain period, numbers begin to repeat, and it is possible to define this period. Obviously, an 
attacker can take advantage of such knowledge.

*Hardware generators* are usually based on stochastic processes that are hard or impossible to predict. Special sensors 
detect the noise of certain processes (e.g. Zener breakdown diodes, nuclear radiation), digitize it, and produce a 
stream of random bits. Based on the data of the stream, you can generate keys and use them in cryptographic schemes.

We will give you a relevant example. In the early stages of Bitcoin's development, there was only one wallet for Android 
devices—Bitcoin Wallet. The creators of this application had occasionally left a vulnerability in the code of the random 
number generator software. It was generating numbers in a certain narrow range, so it was possible to predict the subset 
of possible keys that belonged to users of this wallet. An attacker could iterate over the keys in the subset and have a 
high probability of finding those to which someone's coins belonged. And that's what happened. This caused a great 
scandal because a significant number of bitcoins were stolen. So, an update eliminating this vulnerability was released 
promptly, but the theft had already happened.

It is vital to pay special attention to the generation of random numbers. Some random number generators can combine both 
software and hardware implementations. Also, in order to improve the randomness, developers have introduced more 
*entropy* (unpredictability) [30] into the process of generating random numbers (e.g., you can use noise from a 
smartphone's microphone, gyroscope, any accelerometer data, etc.).

*Key compromise* is the state when an unauthorized person has access to secret information; it also implies the 
potential of such access or even the suspicion of such a possibility.

A compromised private key is a serious threat to any information security system. Therefore special measures are taken 
to protect private keys (or other confidential data): sensitive data is never written on the hard drive of a computer in 
the form of plaintext but rather stored on a separate medium which is encrypted, password protected, etc.

If keys are suspected of being compromised, they should be discarded and substituted.

### Concepts of one-way function and NP-complete problem
Before getting acquainted with hash functions, let's consider what a one-way function is and what features it has. 
A one-way function is a mathematical function for which:

* Obtaining its output value for any input argument is rather simple 
* Obtaining an input argument for its output value is very difficult (this means solving an NP-complete problem)

A simple example can be a broken cup: it is quite troublesome to pick up all its shards and restore them back to an 
unbroken cup. The same works with one-way functions: it is assumed that you cannot restore the initial message if you 
only have the output data. Theoretically, this is possible, but in practice, this task may prove to be extremely 
difficult (provided that a particular one-way function is sufficiently reliable).   

An NP-complete problem is this specific task of finding the initial message (to be more precise, the object which 
satisfies specific conditions). Following our example, solving the NP-complete problem is equal to restoring the 
unbroken cup. Finding the object is a complex task since it requires searching over a large number of possible options. 
Though, having a ready-made solution, you can check quite easily whether it meets the conditions.

A lack of a fast solution to NP-complete problems is crucial for modern cryptography: if there will be a way to solve 
the problem in a reasonable time (not millions of years), then a vast number of modern cryptographic primitives are at 
risk. Some examples of an NP-complete problem are the task of finding the preimage of a hash function and the task of 
finding a private key matching a specific public key as well as the so-called traveling salesman problem (we will 
discuss it a little more).

The traveling salesman problem is about finding the most advantageous route of all possible ones. According to the 
terms, one is to pass through all the marked cities and, after that, return to the initial city. Moving between two 
cities has a certain cost. To solve this problem and choose the optimal route, a salesman is to look over all the 
possible ways of moving. Note that the complexity of finding such a route grows exponentially as the number of the 
cities increases. If there are 5 cities in the terms of the problem, we will get 12 possible routes, yet given 10 
cities, we will have to look over 181,400 routes.

### Hash functions
*A hash function is a function that converts a set of input data of arbitrary length into an output bit string of fixed 
length that is executed using a certain algorithm.*

A hash function is a one-way function, meaning that having an output value (a number of a certain length), you cannot 
determine the data that has been submitted at the input. It is considered cryptographically secure if it can be attacked 
only with brute force. This means that the only solution to ensure that an output value has a specified value is to 
iterate over all possible input values. Schematically, a hash function is shown in Figure 3.2.

[Figure 3.2] - Work principle of a hash function

At the input, the hash function can receive a message of almost unlimited size (any data). At the output, a unique 
identifier (a hash value) is obtained. Having a hash value obtained with a cryptographically secure hash function, it is 
impossible to determine which data was originally submitted to its input. Moreover, Bitcoin uses several different 
hashing algorithms.

The principle of work of a hash function can be understood through the example of a function which sums all the digits 
in an input message and produces the result of one symbol length. The features of this function are as follows. Firstly, 
the result is obtained fast enough because of the simplicity of the counting algorithm. Secondly, this function is 
one-way as the output value contains only the data about the sum in a message but not the position of digits. Thus, the 
complexity of guessing the initial message grows with the length of the message itself (Fig. 3.3).

[Figure 3.3] - Example of a simple hash function operation

However, using this function might be insecure as it is relatively easy to find certain collisions in it: in this case, 
it is possible to substitute an input message (i.e., submit a message with the same digits to the input of the function) 
to get the same result (Fig. 3.4).

[Figure 3.4] - Example of hash function collision

Now, let's consider what a hash function must feature so that its use would be sufficiently secure.

> **Requirements for a hash function**
>> * Resistance to collisions
>> * Resistance to finding its first preimage
>> * Resistance to finding its second preimage

*Resistance to collisions* means that there is no algorithm that could find collisions in a comparatively short time. A 
collision is a situation when there are several input values that match the same value at the output of a hash function 
(Fig. 3.5). 

[Figure 3.5] - Hash function collision

*Resistance to finding the first preimage* (*non-invertibility*) implies that knowing the corresponding hash value will 
not allow you to restore an initial message in a realistic timeframe (one life may not be enough).

*Resistance to finding the second preimage* implies that having an initial message and a corresponding hash value, a 
party cannot create another message which would have the same hash function at its output.

Also, a cryptographically resistant hash function must ensure that changing even one input bit will, on average, cause 
the alteration of a half of the output bits. This feature is easily illustrated through the following example 
(Fig. 3.6). Bob creates a transaction in which he sends 10 bitcoins to Alice and then obtains the corresponding hash 
value. If someone would want to substitute the transaction by changing the amount of transfer (say, not 10 but 100 BTC), 
then the transaction counterfeit will be detected immediately.

[Figure 3.6] - How output value of a hash function changes depending on the input

Among existing hash functions, one of the good examples is SHA-1 [31], which is considered relatively reliable and with 
a functioning principle that is quite easy to explain. The essence of its functioning lies in the cyclical shuffling 
(80 cycles) and the usage of byte operations (and, xor, rot, add, or) on input data. In Figure 3.7, you can see the 
operation of 1 cycle of SHA-1 (operations can be very simple and be performed on the most primitive hardware devices), 
where

* К<sub>t</sub> is the constant value,
* F<sub>t</sub> is the variable function with input data (which changes every 20 cycles), 
* W<sub>i</sub> is the element of modified input data (4 bytes),
* <<<*x* is the rotate shift of *x* positions to the left.

[]







